package com.jipple.sql.catalyst.expressions.codegen;

import java.util.List;
import java.util.stream.Collectors;

/**
 * A block of java code. Including a sequence of code parts and some inputs to this block.
 * The actual java code is generated by embedding the inputs into the code parts. Here we keep
 * inputs of JavaCode instead of simply folding them as a string of code, because we need to
 * track expressions (ExprValue) in this code block. We need to be able to manipulate the
 * expressions later without changing the behavior of this code block in some applications, e.g.,
 * method splitting.
 */
public class CodeBlock extends Block {
    private final List<String> codeParts;
    private final List<JavaCode> blockInputs;
    private String cachedCode;

    public CodeBlock(List<String> codeParts, List<JavaCode> blockInputs) {
        this.codeParts = codeParts;
        this.blockInputs = blockInputs;
    }

    public List<JavaCode> blockInputs() {
        return blockInputs;
    }

    @Override
    public List<Block> children() {
        return blockInputs.stream()
            .filter(Block.class::isInstance)
            .map(Block.class::cast)
            .collect(Collectors.toList());
    }

    @Override
    public String code() {
        if (cachedCode == null) {
            StringBuilder buf = new StringBuilder(512);
            int partIndex = 0;
            int inputIndex = 0;

            if (partIndex < codeParts.size()) {
                buf.append(codeParts.get(partIndex++));
            }

            while (partIndex < codeParts.size() && inputIndex < blockInputs.size()) {
                buf.append(blockInputs.get(inputIndex++).toString());
                if (partIndex < codeParts.size()) {
                    buf.append(codeParts.get(partIndex++));
                }
            }

            cachedCode = buf.toString();
        }
        return cachedCode;
    }

    @Override
    public Object[] args() {
        return new Object[]{codeParts, blockInputs};
    }

    @Override
    protected Block withNewChildrenInternal(List<Block> newChildren) {
        // Filter blockInputs to get only Block instances, then replace them with newChildren
        List<JavaCode> newBlockInputs = new java.util.ArrayList<>(blockInputs);
        int childIndex = 0;
        for (int i = 0; i < newBlockInputs.size(); i++) {
            if (newBlockInputs.get(i) instanceof Block) {
                if (childIndex < newChildren.size()) {
                    newBlockInputs.set(i, newChildren.get(childIndex++));
                }
            }
        }
        return new CodeBlock(codeParts, newBlockInputs);
    }
}

