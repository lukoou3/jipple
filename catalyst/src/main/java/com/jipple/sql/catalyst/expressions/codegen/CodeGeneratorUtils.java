package com.jipple.sql.catalyst.expressions.codegen;

import com.jipple.collection.Option;
import com.jipple.sql.catalyst.InternalRow;
import com.jipple.sql.catalyst.expressions.Expression;
import com.jipple.sql.catalyst.expressions.UnsafeRow;
import com.jipple.sql.catalyst.expressions.UnsafeArrayData;
import com.jipple.sql.catalyst.expressions.UnsafeMapData;
import com.jipple.sql.catalyst.types.*;
import com.jipple.sql.catalyst.util.ArrayData;
import com.jipple.sql.catalyst.util.MapData;
import com.jipple.sql.catalyst.util.UnsafeRowUtils;
import com.jipple.sql.errors.QueryExecutionErrors;
import com.jipple.sql.types.*;
import com.jipple.unsafe.Platform;
import com.jipple.unsafe.types.CalendarInterval;
import com.jipple.unsafe.types.UTF8String;
import com.jipple.util.ParentClassLoader;
import com.jipple.util.Utils;
import org.codehaus.commons.compiler.CompileException;
import org.codehaus.commons.compiler.InternalCompilerException;
import org.codehaus.janino.ClassBodyEvaluator;
import org.codehaus.janino.util.ClassFile;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.io.ByteArrayInputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.jipple.tuple.Tuple2;
import com.jipple.util.NonFateSharingCache;
import com.jipple.util.NonFateSharingLoadingCache;
import com.google.common.util.concurrent.ExecutionError;
import com.google.common.util.concurrent.UncheckedExecutionException;

import java.util.function.Function;

/**
 * Utility class for code generation, converted from Scala object CodeGenerator.
 * This class provides static methods for generating Java code and compiling it.
 */
public final class CodeGeneratorUtils {
    private static final Logger logger = LoggerFactory.getLogger(CodeGeneratorUtils.class);

    // This is the default value of HugeMethodLimit in the OpenJDK HotSpot JVM,
    // beyond which methods will be rejected from JIT compilation
    public static final int DEFAULT_JVM_HUGE_METHOD_LIMIT = 8000;

    // The max valid length of method parameters in JVM.
    public static final int MAX_JVM_METHOD_PARAMS_LENGTH = 255;

    // The max number of constant pool entries in JVM.
    public static final int MAX_JVM_CONSTANT_POOL_SIZE = 65535;

    // This is the threshold over which the methods in an inner class are grouped in a single
    // method which is going to be called by the outer class instead of the many small ones
    public static final int MERGE_SPLIT_METHODS_THRESHOLD = 3;

    // The number of named constants that can exist in the class is limited by the Constant Pool
    // limit, 65,536. We cannot know how many constants will be inserted for a class, so we use a
    // threshold of 1000k bytes to determine when a function should be inlined to a private, inner
    // class.
    public static final int GENERATED_CLASS_SIZE_THRESHOLD = 1000000;

    // This is the threshold for the number of global variables, whose types are primitive type or
    // complex type (e.g. more than one-dimensional array), that will be placed at the outer class
    public static final int OUTER_CLASS_VARIABLES_THRESHOLD = 10000;

    // This is the maximum number of array elements to keep global variables in one Java array
    // 32767 is the maximum integer value that does not require a constant pool entry in a Java
    // bytecode instruction
    public static final int MUTABLESTATEARRAY_SIZE_LIMIT = 32768;

    // The Java source code generated by whole-stage codegen on the Driver side is sent to each
    // Executor for compilation and data processing. This is very effective in processing large
    // amounts of data in a distributed environment. However, in the test environment,
    // because the amount of data is not large or not executed in parallel, the compilation time
    // of these Java source code will become a major part of the entire test runtime. When
    // running test cases, we summarize the total compilation time and output it to the execution
    // log for easy analysis and view.
    private static long _compileTime = 0L;

    // Returns the total compile time of Java source code in nanoseconds.
    // Visible for testing
    public static long compileTime() {
        return _compileTime;
    }

    // Reset compile time.
    // Visible for testing
    public static void resetCompileTime() {
        _compileTime = 0L;
    }

    /**
     * Name of Java primitive data type
     */
    public static final String JAVA_BOOLEAN = "boolean";
    public static final String JAVA_BYTE = "byte";
    public static final String JAVA_SHORT = "short";
    public static final String JAVA_INT = "int";
    public static final String JAVA_LONG = "long";
    public static final String JAVA_FLOAT = "float";
    public static final String JAVA_DOUBLE = "double";

    /**
     * List of java primitive data types
     */
    private static final List<String> PRIMITIVE_TYPES = Arrays.asList(
            JAVA_BOOLEAN, JAVA_BYTE, JAVA_SHORT, JAVA_INT, JAVA_LONG, JAVA_FLOAT, JAVA_DOUBLE);

    /**
     * A cache of generated classes.
     * <p>
     * From the Guava Docs: A Cache is similar to ConcurrentMap, but not quite the same. The most
     * fundamental difference is that a ConcurrentMap persists all elements that are added to it until
     * they are explicitly removed. A Cache on the other hand is generally configured to evict entries
     * automatically, in order to constrain its memory footprint.  Note that this cache does not use
     * weak keys/values and thus does not respond to memory pressure.
     * <p>
     * Codegen can be slow. Use a non fate sharing cache in case a query gets canceled during codegen
     * while other queries wait on the same code, so that those other queries don't get wrongly
     * aborted. See NonFateSharingCache for more details.
     */
    private static final NonFateSharingLoadingCache<Tuple2<HashableWeakReference, CodeAndComment>, Tuple2<GeneratedClass, ByteCodeStats>> cache =
            NonFateSharingCache.create(
                    (Function<Tuple2<HashableWeakReference, CodeAndComment>, Tuple2<GeneratedClass, ByteCodeStats>>) key -> {
                        CodeAndComment code = key._2;
                        long startTime = System.nanoTime();
                        Tuple2<GeneratedClass, ByteCodeStats> result = doCompile(code);
                        long endTime = System.nanoTime();
                        long duration = endTime - startTime;
                        double timeMs = (double) duration / com.jipple.sql.catalyst.util.DateTimeConstants.NANOS_PER_MILLIS;
                        logger.info("Code generated in {} ms", timeMs);
                        _compileTime += duration;
                        return result;
                    },
                    100L  // SQLConf.get.codegenCacheMaxEntries
            );

    private CodeGeneratorUtils() {
        // Utility class, prevent instantiation
    }

    /**
     * Compile the Java source code into a Java class, using Janino.
     *
     * @return a pair of a generated class and the bytecode statistics of generated functions.
     */
    public static Tuple2<GeneratedClass, ByteCodeStats> compile(CodeAndComment code) {
        try {
            ClassLoader classLoader = Utils.getContextOrJippleClassLoader();
            HashableWeakReference classLoaderRef = new HashableWeakReference(classLoader);
            Tuple2<HashableWeakReference, CodeAndComment> key = Tuple2.of(classLoaderRef, code);
            return cache.get(key);
        } catch (UncheckedExecutionException | ExecutionError e) {
            // Cache.get() may wrap the original exception. See the following URL
            // https://guava.dev/releases/14.0.1/api/docs/com/google/common/cache/
            //   Cache.html#get(K,%20java.util.concurrent.Callable)
            Throwable cause = e.getCause();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else if (cause instanceof Error) {
                throw (Error) cause;
            } else {
                throw new RuntimeException(cause);
            }
        }
    }

    /**
     * Compile the Java source code into a Java class, using Janino.
     */
    private static Tuple2<GeneratedClass, ByteCodeStats> doCompile(CodeAndComment code) {
        ClassBodyEvaluator evaluator = new ClassBodyEvaluator();

        // A special classloader used to wrap the actual parent classloader of
        // org.codehaus.janino.ClassBodyEvaluator (see CodeGenerator.doCompile). This classloader
        // does not throw a ClassNotFoundException with a cause set (i.e. exception.getCause returns
        // a null). This classloader is needed because janino will throw the exception directly if
        // the parent classloader throws a ClassNotFoundException with cause set instead of trying to
        // find other possible classes (see org.codehaus.janinoClassLoaderIClassLoader's
        // findIClass method). Please also see https://issues.apache.org/jira/browse/SPARK-15622 and
        // https://issues.apache.org/jira/browse/SPARK-11636.
        ClassLoader parentClassLoader = new ParentClassLoader(Utils.getContextOrJippleClassLoader());
        evaluator.setParentClassLoader(parentClassLoader);
        // Cannot be under package codegen, or fail with java.lang.InstantiationException
        evaluator.setClassName("com.jipple.sql.catalyst.expressions.GeneratedClass");
        evaluator.setDefaultImports(
                Platform.class.getName(),
                InternalRow.class.getName(),
                UnsafeRow.class.getName(),
                UTF8String.class.getName(),
                com.jipple.sql.types.Decimal.class.getName(),
                CalendarInterval.class.getName(),
                ArrayData.class.getName(),
                UnsafeArrayData.class.getName(),
                MapData.class.getName(),
                UnsafeMapData.class.getName(),
                Expression.class.getName(),
                QueryExecutionErrors.class.getName().replace("$", "")
        );
        evaluator.setExtendedClass(GeneratedClass.class);

        if (logger.isDebugEnabled()) {
            // Only add extra debugging info to byte code when we are going to print the source code.
            evaluator.setDebuggingInformation(true, true, false);
            logger.debug("\n{}", CodeFormatter.format(code));
        }

        ByteCodeStats codeStats;
        try {
            evaluator.cook("generated.java", code.body);
            codeStats = updateAndGetCompilationStats(evaluator);
        } catch (InternalCompilerException e) {
            // TODO: Implement QueryExecutionErrors methods
            String msg = "Failed to compile code: " + e.getMessage();
            logger.error(msg, e);
            logGeneratedCode(code);
            throw new RuntimeException("Internal compiler error", e);
        } catch (CompileException e) {
            String msg = "Failed to compile code: " + e.getMessage();
            logger.error(msg, e);
            logGeneratedCode(code);
            throw new RuntimeException("Compiler error", e);
        }

        try {
            GeneratedClass generatedClass = (GeneratedClass) evaluator.getClazz().getConstructor().newInstance();
            return Tuple2.of(generatedClass, codeStats);
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate generated class", e);
        }
    }

    private static void logGeneratedCode(CodeAndComment code) {
        int maxLines = 1000; // SQLConf.get.loggingMaxLinesForCodegen
        // TODO: Implement CodeFormatter
        String codeStr = code.body;
        if (codeStr.length() > maxLines * 100) { // Rough estimate
            codeStr = codeStr.substring(0, maxLines * 100) + "...";
        }
        if (Utils.isTesting()) {
            logger.error("\n{}", codeStr);
        } else {
            logger.info("\n{}", codeStr);
        }
    }

    /**
     * Returns the bytecode statistics (max method bytecode size, max constant pool size, and
     * # of inner classes) of generated classes by inspecting Janino classes.
     * Also, this method updates the metrics information.
     */
    private static ByteCodeStats updateAndGetCompilationStats(ClassBodyEvaluator evaluator) {
        // First retrieve the generated classes.
        Map<String, byte[]> classes = evaluator.getBytecodes();

        // Then walk the classes to get at the method bytecode.
        Class<?> codeAttr;
        try {
            codeAttr = Class.forName("org.codehaus.janino.util.ClassFile$CodeAttribute");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        java.lang.reflect.Field codeAttrField;
        try {
            codeAttrField = codeAttr.getDeclaredField("code");
            codeAttrField.setAccessible(true);
        } catch (NoSuchFieldException e) {
            throw new RuntimeException(e);
        }

        List<int[]> codeStatsList = new ArrayList<>();
        for (Map.Entry<String, byte[]> entry : classes.entrySet()) {
            byte[] classBytes = entry.getValue();
            //CodegenMetrics.METRIC_GENERATED_CLASS_BYTECODE_SIZE.update(classBytes.length)
            try {
                ClassFile cf = new ClassFile(new ByteArrayInputStream(classBytes));
                int constPoolSize = cf.getConstantPoolSize();
                List<Integer> methodCodeSizes = new ArrayList<>();

                for (org.codehaus.janino.util.ClassFile.MethodInfo method : cf.methodInfos) {
                    for (Object attr : method.getAttributes()) {
                        if (attr.getClass().equals(codeAttr)) {
                            byte[] byteCode = (byte[]) codeAttrField.get(attr);
                            int byteCodeSize = byteCode.length;
                            //CodegenMetrics.METRIC_GENERATED_METHOD_BYTECODE_SIZE.update(byteCodeSize)

                            if (byteCodeSize > DEFAULT_JVM_HUGE_METHOD_LIMIT) {
                                logger.info("Generated method too long to be JIT compiled: {}.{} is {} bytes",
                                        cf.getThisClassName(), method.getName(), byteCodeSize);
                            }

                            methodCodeSizes.add(byteCodeSize);
                        }
                    }
                }

                int maxMethodSize = methodCodeSizes.isEmpty() ? -1 : Collections.max(methodCodeSizes);
                codeStatsList.add(new int[]{maxMethodSize, constPoolSize});
            } catch (Error e) {
                // Fatal errors should be rethrown
                throw e;
            } catch (Exception e) {
                // Non-fatal exceptions are caught and logged
                logger.warn("Error calculating stats of compiled class.", e);
                codeStatsList.add(new int[]{-1, -1});
            }
        }

        int maxMethodCodeSize = codeStatsList.stream()
                .mapToInt(arr -> arr[0])
                .max()
                .orElse(-1);
        int maxConstPoolSize = codeStatsList.stream()
                .mapToInt(arr -> arr[1])
                .max()
                .orElse(-1);
        // Minus 2 for `GeneratedClass` and an outer-most generated class
        int numInnerClasses = classes.size() - 2;

        return new ByteCodeStats(maxMethodCodeSize, maxConstPoolSize, numInnerClasses);
    }

    /**
     * Returns true if a Java type is Java primitive type
     */
    public static boolean isPrimitiveType(String jt) {
        return PRIMITIVE_TYPES.contains(jt);
    }

    public static boolean isPrimitiveType(DataType dt) {
        return isPrimitiveType(javaType(dt));
    }

    /**
     * Returns the specialized code to access a value from `inputRow` at `ordinal`.
     */
    public static String getValue(String input, DataType dataType, String ordinal) {
        String jt = javaType(dataType);
        if (isPrimitiveType(jt)) {
            return input + ".get" + primitiveTypeName(jt) + "(" + ordinal + ")";
        } else {
            PhysicalDataType<?> physicalType = PhysicalDataType.of(dataType);
            if (physicalType instanceof PhysicalArrayType) {
                return input + ".getArray(" + ordinal + ")";
            } else if (physicalType instanceof PhysicalBinaryType) {
                return input + ".getBinary(" + ordinal + ")";
            } else if (physicalType instanceof PhysicalCalendarIntervalType) {
                return input + ".getInterval(" + ordinal + ")";
            } else if (physicalType instanceof PhysicalDecimalType) {
                PhysicalDecimalType t = (PhysicalDecimalType) physicalType;
                return input + ".getDecimal(" + ordinal + ", " + t.precision + ", " + t.scale + ")";
            } else if (physicalType instanceof PhysicalMapType) {
                return input + ".getMap(" + ordinal + ")";
            } else if (physicalType instanceof PhysicalNullType) {
                return "null";
            } else if (physicalType instanceof PhysicalStringType) {
                return input + ".getUTF8String(" + ordinal + ")";
            } else if (physicalType instanceof PhysicalStructType) {
                PhysicalStructType t = (PhysicalStructType) physicalType;
                return input + ".getStruct(" + ordinal + ", " + t.fields.length + ")";
            } else {
                return "((" + jt + ")" + input + ".get(" + ordinal + ", null))";
            }
        }
    }

    /**
     * Generates code creating a [[UnsafeArrayData]] or
     * [[com.jipple.sql.catalyst.util.GenericArrayData]] based on given parameters.
     *
     * @param arrayName              name of the array to create
     * @param elementType            data type of the elements in source array
     * @param numElements            code representing the number of elements the array should contain
     * @param additionalErrorMessage string to include in the error message
     * @return code representing the allocation of [[ArrayData]]
     */
    public static String createArrayData(
            String arrayName,
            DataType elementType,
            String numElements,
            String additionalErrorMessage) {
        int elementSize = isPrimitiveType(elementType) ? elementType.defaultSize() : -1;
        return template(
                "ArrayData ${arrayName} = ArrayData.allocateArrayData(${elementSize}, ${numElements}, \"${additionalErrorMessage}\");",
                Map.of(
                        "arrayName", arrayName,
                        "elementSize", elementSize,
                        "numElements", numElements,
                        "additionalErrorMessage", additionalErrorMessage
                )
        );
    }

    /**
     * Generates assignment code for an [[ArrayData]]
     *
     * @param dstArray      name of the array to be assigned
     * @param elementType   data type of the elements in destination and source arrays
     * @param srcArray      name of the array to be read
     * @param needNullCheck value which shows whether a nullcheck is required for the returning
     *                      assignment
     * @param dstArrayIndex an index variable to access each element of destination array
     * @param srcArrayIndex an index variable to access each element of source array
     * @return code representing an assignment to each element of the [[ArrayData]], which requires
     * a pair of destination and source loop index variables
     */
    public static String createArrayAssignment(
            String dstArray,
            DataType elementType,
            String srcArray,
            String dstArrayIndex,
            String srcArrayIndex,
            boolean needNullCheck) {
        Option<String> isNullCheck = needNullCheck ? Option.some(srcArray + ".isNullAt(" + srcArrayIndex + ")") : Option.none();
        return setArrayElement(dstArray, elementType, dstArrayIndex,
                getValue(srcArray, elementType, srcArrayIndex),
                isNullCheck);
    }

    /**
     * Returns the code to update a column in Row for a given DataType.
     */
    public static String setColumn(String row, DataType dataType, int ordinal, String value) {
        String jt = javaType(dataType);
        if (isPrimitiveType(jt)) {
            return row + ".set" + primitiveTypeName(jt) + "(" + ordinal + ", " + value + ")";
        } else if (dataType instanceof CalendarIntervalType) {
            return row + ".setInterval(" + ordinal + ", " + value + ")";
        } else if (dataType instanceof DecimalType) {
            DecimalType t = (DecimalType) dataType;
            return row + ".setDecimal(" + ordinal + ", " + value + ", " + t.precision() + ")"; // DecimalType has precision() method
        } else if (dataType instanceof StringType || dataType instanceof StructType ||
                dataType instanceof ArrayType || dataType instanceof MapType) {
            // The UTF8String, InternalRow, ArrayData and MapData may came from UnsafeRow, we should copy
            // it to avoid keeping a "pointer" to a memory region which may get updated afterwards.
            // 不copy，不使用堆外内存
            return row + ".update(" + ordinal + ", " + value + ")";
        } else {
            return row + ".update(" + ordinal + ", " + value + ")";
        }
    }

    /**
     * Update a column in MutableRow from ExprCode.
     *
     * @param isVectorized True if the underlying row is of type `ColumnarBatch.Row`, false otherwise
     */
    public static String updateColumn(
            String row,
            DataType dataType,
            int ordinal,
            ExprCode ev,
            boolean nullable,
            boolean isVectorized) {
        if (nullable) {
            // Can't call setNullAt on DecimalType/CalendarIntervalType, because we need to keep the
            // offset
            if (!isVectorized && UnsafeRowUtils.avoidSetNullAt(dataType)) {
                return Block.block(
                        """
                                if (!${isNull}) {
                                  ${setColumnCode};
                                } else {
                                  ${setColumnNullCode};
                                }
                                """,
                        Map.of(
                                "isNull", ev.isNull,
                                "setColumnCode", setColumn(row, dataType, ordinal, ev.value.toString()),
                                "setColumnNullCode", setColumn(row, dataType, ordinal, "null")
                        )
                ).toString();
            } else {
                return Block.block(
                        """
                                if (!${isNull}) {
                                  ${setColumnCode};
                                } else {
                                  ${row}.setNullAt(${ordinal});
                                }
                                """,
                        Map.of(
                                "isNull", ev.isNull,
                                "setColumnCode", setColumn(row, dataType, ordinal, ev.value.toString()),
                                "row", row,
                                "ordinal", ordinal
                        )
                ).toString();
            }
        } else {
            return setColumn(row, dataType, ordinal, ev.value.toString()) + ";";
        }
    }

    /**
     * Update a column in MutableRow from ExprCode.
     */
    public static String updateColumn(
            String row,
            DataType dataType,
            int ordinal,
            ExprCode ev,
            boolean nullable) {
        return updateColumn(row, dataType, ordinal, ev, nullable, false);
    }

    /**
     * Returns the specialized code to set a given value in a column vector for a given `DataType`.
     */
    public static String setValue(String vector, String rowId, DataType dataType, String value) {
        String jt = javaType(dataType);
        if (isPrimitiveType(jt)) {
            return vector + ".put" + primitiveTypeName(jt) + "(" + rowId + ", " + value + ");";
        } else if (dataType instanceof DecimalType) {
            DecimalType t = (DecimalType) dataType;
            return vector + ".putDecimal(" + rowId + ", " + value + ", " + t.precision() + ");"; // DecimalType has precision() method
        } else if (dataType instanceof CalendarIntervalType) {
            return vector + ".putInterval(" + rowId + ", " + value + ");";
        } else if (dataType instanceof StringType) {
            return vector + ".putByteArray(" + rowId + ", " + value + ".getBytes());";
        } else {
            throw new IllegalArgumentException("cannot generate code for unsupported type: " + dataType);
        }
    }

    /**
     * Generates code of setter for an [[ArrayData]].
     */
    public static String setArrayElement(
            String array,
            DataType elementType,
            String i,
            String value,
            Option<String> isNull) {
        boolean isPrimitive = isPrimitiveType(elementType);
        String setFunc = isPrimitive ? "set" + primitiveTypeName(elementType) : "update";
        if (isNull.isDefined() && isPrimitive) {
            return Block.block(
                    """
                            if (${isNull}) {
                              ${array}.setNullAt(${i});
                            } else {
                              ${array}.${setFunc}(${i}, ${value});
                            }
                            """,
                    Map.of(
                            "isNull", isNull.get(),
                            "array", array,
                            "i", i,
                            "setFunc", setFunc,
                            "value", value
                    )
            ).toString();
        } else {
            return array + "." + setFunc + "(" + i + ", " + value + ");";
        }
    }

    /**
     * Generates code of setter for an [[ArrayData]].
     */
    public static String setArrayElement(
            String array,
            DataType elementType,
            String i,
            String value) {
        return setArrayElement(array, elementType, i, value, Option.none());
    }

    /**
     * Returns the specialized code to set a given value in a column vector for a given `DataType`
     * that could potentially be nullable.
     */
    public static String updateColumn(
            String vector,
            String rowId,
            DataType dataType,
            ExprCode ev,
            boolean nullable) {
        if (nullable) {
            return Block.block(
                    """
                            if (!${isNull}) {
                              ${setValueCode}
                            } else {
                              ${vector}.putNull(${rowId});
                            }
                            """,
                    Map.of(
                            "isNull", ev.isNull,
                            "setValueCode", setValue(vector, rowId, dataType, ev.value.toString()),
                            "vector", vector,
                            "rowId", rowId
                    )
            ).toString();
        } else {
            return setValue(vector, rowId, dataType, ev.value.toString()) + ";";
        }
    }

    /**
     * Returns the specialized code to access a value from a column vector for a given `DataType`.
     */
    public static String getValueFromVector(String vector, DataType dataType, String rowId) {
        DataType sqlDataType = dataType; // case udt: UserDefinedType[_] => udt.sqlType

        if (sqlDataType instanceof StructType) {
            // `ColumnVector.getStruct` is different from `InternalRow.getStruct`, it only takes an
            // `ordinal` parameter.
            return vector + ".getStruct(" + rowId + ")";
        } else {
            return getValue(vector, sqlDataType, rowId);
        }
    }

    /**
     * Returns the name used in accessor and setter for a Java primitive type.
     */
    public static String primitiveTypeName(String jt) {
        if (JAVA_INT.equals(jt)) {
            return "Int";
        } else {
            return boxedType(jt);
        }
    }

    public static String primitiveTypeName(DataType dt) {
        return primitiveTypeName(javaType(dt));
    }

    /**
     * Returns the Java type for a DataType.
     */
    public static String javaType(DataType dt) {
        if (dt instanceof ObjectType) {
            ObjectType ot = (ObjectType) dt;
            Class<?> cls = ot.cls;
            if (cls.isArray()) {
                return javaType(new ObjectType(cls.getComponentType())) + "[]";
            } else {
                return cls.getName();
            }
        }
        PhysicalDataType<?> physicalType = PhysicalDataType.of(dt);
        if (physicalType instanceof PhysicalArrayType) {
            return "ArrayData";
        } else if (physicalType instanceof PhysicalBinaryType) {
            return "byte[]";
        } else if (physicalType instanceof PhysicalBooleanType) {
            return JAVA_BOOLEAN;
        } else if (physicalType instanceof PhysicalCalendarIntervalType) {
            return "CalendarInterval";
        } else if (physicalType instanceof PhysicalIntegerType) {
            return JAVA_INT;
        } else if (physicalType instanceof PhysicalDecimalType) {
            return "Decimal";
        } else if (physicalType instanceof PhysicalDoubleType) {
            return JAVA_DOUBLE;
        } else if (physicalType instanceof PhysicalFloatType) {
            return JAVA_FLOAT;
        } else if (physicalType instanceof PhysicalLongType) {
            return JAVA_LONG;
        } else if (physicalType instanceof PhysicalMapType) {
            return "MapData";
        } else if (physicalType instanceof PhysicalStringType) {
            return "UTF8String";
        } else if (physicalType instanceof PhysicalStructType) {
            return "InternalRow";
        } else {
            return "Object";
        }

    }

    public static Class<?> javaClass(DataType dt) {
        if (dt instanceof BooleanType) {
            return Boolean.TYPE;
        } else if (dt instanceof IntegerType || dt instanceof DateType) {
            return Integer.TYPE;
        } else if (dt instanceof LongType || dt instanceof TimestampType || dt instanceof TimestampNTZType) {
            return Long.TYPE;
        } else if (dt instanceof FloatType) {
            return Float.TYPE;
        } else if (dt instanceof DoubleType) {
            return Double.TYPE;
        } else if (dt instanceof DecimalType) {
            return Decimal.class;
        } else if (dt instanceof BinaryType) {
            return byte[].class;
        } else if (dt instanceof StringType) {
            return UTF8String.class;
        } else if (dt instanceof CalendarIntervalType) {
            return CalendarInterval.class;
        } else if (dt instanceof StructType) {
            return InternalRow.class;
        } else if (dt instanceof ArrayType) {
            return ArrayData.class;
        } else if (dt instanceof MapType) {
            return MapData.class;
        } else if (dt instanceof ObjectType o) {
            return o.cls;
        } else {
            return Object.class;
        }
    }

    /**
     * Returns the boxed type in Java.
     */
    public static String boxedType(String jt) {
        switch (jt) {
            case JAVA_BOOLEAN:
                return "Boolean";
            case JAVA_BYTE:
                return "Byte";
            case JAVA_SHORT:
                return "Short";
            case JAVA_INT:
                return "Integer";
            case JAVA_LONG:
                return "Long";
            case JAVA_FLOAT:
                return "Float";
            case JAVA_DOUBLE:
                return "Double";
            default:
                return jt;
        }
    }

    public static String boxedType(DataType dt) {
        return boxedType(javaType(dt));
    }

    public static String typeName(Class<?> clazz) {
        if (clazz.isArray()) {
            return typeName(clazz.getComponentType()) + "[]";
        } else {
            return clazz.getName();
        }
    }

    /**
     * Returns the representation of default value for a given Java Type.
     *
     * @param jt        the string name of the Java type
     * @param typedNull if true, for null literals, return a typed (with a cast) version
     */
    public static String defaultValue(String jt, boolean typedNull) {
        switch (jt) {
            case JAVA_BOOLEAN:
                return "false";
            case JAVA_BYTE:
                return "(byte)-1";
            case JAVA_SHORT:
                return "(short)-1";
            case JAVA_INT:
                return "-1";
            case JAVA_LONG:
                return "-1L";
            case JAVA_FLOAT:
                return "-1.0f";
            case JAVA_DOUBLE:
                return "-1.0";
            default:
                if (typedNull) {
                    return "((" + jt + ")null)";
                } else {
                    return "null";
                }
        }
    }

    public static String defaultValue(DataType dt, boolean typedNull) {
        return defaultValue(javaType(dt), typedNull);
    }

    public static String defaultValue(DataType dt) {
        return defaultValue(dt, false);
    }

    /**
     * Returns the length of parameters for a Java method descriptor. `this` contributes one unit
     * and a parameter of type long or double contributes two units. Besides, for nullable parameter,
     * we also need to pass a boolean parameter for the null status.
     */
    public static int calculateParamLength(List<Expression> params) {
        int total = 1; // Initial value is 1 for `this`.
        for (Expression input : params) {
            String javaType = javaType(input.dataType());
            int javaParamLength = (JAVA_LONG.equals(javaType) || JAVA_DOUBLE.equals(javaType)) ? 2 : 1;
            // For a nullable expression, we need to pass in an extra boolean parameter.
            int nullableParam = input.nullable() ? 1 : 0;
            total += javaParamLength + nullableParam;
        }
        return total;
    }

    public static int calculateParamLengthFromExprValues(List<ExprValue> params) {
        int total = 1; // Initial value is 1 for `this`.
        for (ExprValue input : params) {
            Class<?> javaType = input.javaType();
            int javaParamLength = (Long.TYPE.equals(javaType) || Double.TYPE.equals(javaType)) ? 2 : 1;
            total += javaParamLength;
        }
        return total;
    }

    /**
     * In Java, a method descriptor is valid only if it represents method parameters with a total
     * length less than a pre-defined constant.
     */
    public static boolean isValidParamLength(int paramLength) {
        // This config is only for testing
        return paramLength <= MAX_JVM_METHOD_PARAMS_LENGTH;
    }

    // Pattern to match $$ (escaped dollar) first, then ${placeholder}
    // Order matters: we need to match $$ before matching ${variable}
    private static final Pattern TEMPLATE_PLACEHOLDER_PATTERN = Pattern.compile("(\\$\\$)|\\$\\{([^}]+)\\}");

    /**
     * Replaces placeholders in a template string with values from a map.
     * Supports Java text blocks (""") for multi-line templates.
     *
     * <p>This is a simple string template utility for code generation.
     * Placeholders use the syntax ${key} and will be replaced with the toString()
     * value of the corresponding entry in the variables map.
     *
     * <p>Use $$ to escape a dollar sign (outputs a single $).
     *
     * <p>Example:
     * <pre>{@code
     * String result = CodeGeneratorUtils.template(
     *     "ArrayData ${arrayName} = ArrayData.allocateArrayData(${elementSize}, ${numElements}, \"${additionalErrorMessage}\");",
     *     Map.of(
     *         "arrayName", "arr",
     *         "elementSize", 10,
     *         "numElements", "5",
     *         "additionalErrorMessage", "error"
     *     )
     * );
     * // Result: "ArrayData arr = ArrayData.allocateArrayData(10, 5, \"error\");"
     *
     * // Multi-line using text block (Java 17+)
     * String code = CodeGeneratorUtils.template(
     *     """
     *     ArrayData ${arrayName} = ArrayData.allocateArrayData(
     *       ${elementSize}, ${numElements}, "${additionalErrorMessage}");
     *     """,
     *     Map.of("arrayName", "arr", "elementSize", 10, "numElements", "5", "additionalErrorMessage", "error")
     * );
     *
     * // Escaping: use $$ to output a single $
     * String escaped = CodeGeneratorUtils.template(
     *     "String price = \"$${amount}\";",
     *     Map.of("amount", "100")
     * );
     * // Result: "String price = \"${amount}\";"
     * }</pre>
     *
     * @param template  The template string with ${placeholder} syntax. Can be a text block for multi-line.
     *                  Use $$ to escape a dollar sign.
     * @param variables Map of placeholder names to their values. Values will be converted to string using toString().
     * @return The template string with placeholders replaced by their values
     * @throws IllegalArgumentException if a placeholder is not found in variables or if a value is null
     */
    public static String template(String template, Map<String, Object> variables) {
        if (template == null) {
            return "";
        }
        if (variables == null) {
            throw new IllegalArgumentException("Variables map cannot be null");
        }

        StringBuilder result = new StringBuilder(template.length() * 2);
        Matcher matcher = TEMPLATE_PLACEHOLDER_PATTERN.matcher(template);
        int lastEnd = 0;

        while (matcher.find()) {
            // Add text before the match
            if (matcher.start() > lastEnd) {
                result.append(template, lastEnd, matcher.start());
            }

            String escapedDollar = matcher.group(1); // escaped dollar $$
            String placeholderName = matcher.group(2); // placeholder name in ${variable}

            if (escapedDollar != null) {
                // Escaped dollar: $$ -> $
                result.append('$');
            } else if (placeholderName != null) {
                if (!variables.containsKey(placeholderName)) {
                    throw new IllegalArgumentException(
                            "Placeholder '" + placeholderName + "' not found in variables. Available: " + variables.keySet());
                }

                Object value = variables.get(placeholderName);
                if (value == null) {
                    throw new IllegalArgumentException(
                            "Placeholder '" + placeholderName + "' is null. Available: " + variables.keySet());
                }

                // Convert value to string
                result.append(value.toString());
            }

            lastEnd = matcher.end();
        }

        // Add remaining text after the last match
        if (lastEnd < template.length()) {
            result.append(template, lastEnd, template.length());
        }

        return result.toString();
    }
}

